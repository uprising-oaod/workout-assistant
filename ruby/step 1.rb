# Шпаргалка - Основны языка Ruby с примерами

puts "Hello, Мир!\n=========== "


# Вывод
puts "================= Пример 1. Вывод "
# метод puts, если на входе не строка, puts вызывает метод .to_s для преобразования его к строке
puts "Hello"
puts [1, 2, 3]

# p = .inspect
p "Hello"
p [1, 2, 3]
puts "==================  "

puts "================= Пример 2. Переменные "
first = "Кот1"
second = first
second[1]="и" # Меняется объект, а значит и вторая, и первая переменные
p first
p second
# Переменная указывает на объект.
# Если нужно изменить объект, но сохранить копию оригинала, можно копировать объект с помощью методов .clone или .dup
first = "Кот2"
second = first.clone # СОздаём второй объект из первого.
second[1]="и" # Меняется второй объект, а значит только вторая переменная
p first
p second
# Разница между ними https://www.rubyguides.com/2018/11/dup-vs-clone/

# Однако, в большинстве случаев, клонировние объекта производится автоматически
first = "Кот3"
second = first
second="Кит3" # простое присваивание нового значения, создаётся новый объект
p first
p second
puts "==================  "


puts "================= Пример 3. Базовые типы данных "
# Числа
p 076 # восьмеричное число 62
p 0b010 # двоичное число 2
p 0x89 # шестнадцатеричное число 137
p 123_456 # подчеркивание игнорируется

# Пример, перевести число в двоичную форму
p sprintf("%b", 5)    # метод sprintf заимствован из Си
p 5.to_s(2) # перевести в строку по основанию 2 (можно использовать любое основание до 36)

# поменять две переменные местами без использования третьей вспомогательной
a = 1
b = 2
p a,b
a,b = b,a
p a,b


# операции получение остатка от деления (%), возведение в степень (**).

# преобразование типов
# явное to_f, to_i, to_s
p 123_456.to_f
p 123_456.7.to_i
p 123_456.to_s

# Логический тип true false
# Традиционно имена логических методов заканчиваются на ? (знак вопроса).
# В качестве false может выступать nil, а в качестве true — любой объект.
# nil — это символ пустоты.

# Массивы
# Нет динамических массивов, списков, стеков, всё реализовано методами в классе array
# Большая библиотека итераторов позволяет не использовать циклы для обработки массивов
# Много методов на все случаи
p ["массивы гетерогенны", 42, [4, "тест"]]
# Строки
# методы .inspect и .to_s есть у любого объекта, поэтому любой объект можно преобразовать в строку
# Строки подобны массивам символов, поэтому их часто преобразуют к массивам, чтобы использовать богатый набор методов, а потом результат делают строкой.
p  "Пример, #{'интерполяции'.capitalize}!"
# Ассоциативные массивы
# Работают подобно словарям
hash = {"ключ"=>"значение", 807=>"Значение ключа 807"}

p hash["ключ"]
p hash[807]
p hash["значение"]

# Диапазоны значений. диапазон (класс Range)
# Начало и конец должны быть одного типа данных (одного класса) и быть перечисляемыми, что значит, иметь метод .succ
"a".."z"
"a"..."z" # то же, что и "a".."y"
1..100
1...100 # то же, что и 1..99

# Классы и объекты
# в Ruby всё в конечном счёте принадлежит классу Object.
str = "Это объект - строка"
p str.class #=> String
p str.class.superclass #=> Object

puts "==================  "

# Простой метод
def a
  42
end

p a

# Метод с параметрами
def h(name)
  puts "Привет, #{name.capitalize}!"  # где #{name} - интерполяция в строку
end

p h %(студент)
p h "студент"
p h "интерполяция #{def b; a; end; b}"

# Ещё пример интерполяции. Можно запихнуть что угодно.
puts "The total is #{def b; 5+2; end; b}"

# %w, %i, %q, %r, %x

p array = %w(apple orange coconut) # %w - создать массив из строк
p a = %w(1,2,3 4 5)
p array = %i(apple orange coconut) # %i - создать массив из символов
p string = %q(apple orange coconut) # %q - создать строку не используя кавычки
p string = %q(можно без кавычек, кавычки "экранируются")

p regular_expression = %r([0-9])

# Типы переменных
something = 1 # локальная
@something = 2 # инстансная
Something = 3   # константа
SOMETHING = 4 # константа
$something = 5 # глобальная

# Скобки и двоеточия не требуются, но могут быть использованы.
# Базовые правила:
# Скобки не нужны для метода без аргументов => def foo
# Скобки используются если есть аргументы => def foo(a, b, c)
# Скобки нужны для определния приоритета => (a.size + b.size) * 2


# Ternary operator
puts false ? "yes" : "no"

# Each with block
[1,2,3].each do |n|
  puts n
end

# Case statement
case 20
when 1..20 # Where 1..20 is a Range object.
  puts "Between 1 & 20"
when 21..40
  puts "Between 21 & 40"
else
  puts "Not within a valid range"
end